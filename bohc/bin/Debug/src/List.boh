package boh.std;

public class List<T> implements IIndexedCollection<T>
{
	public static final int INITIAL_CAPACITY = 13;
	private T[] array;
	private int length = 0;
	
	public int size()
	{
		return length;
	}
	
	public int capacity()
	{
		return array.size();
	}
	
	public this(int capacity)
	{
		this.array = new T[capacity];
	}
	public this()
	{
		this(INITIAL_CAPACITY);
	}
	
	public IIterator<T> iterator()
	{
		throw new Exception();
	}
	
	/*public Query<T> query()
	{
		return new Query<T>(this);
	}*/
	
	public T get(int index)
	{
		if (index >= length)
		{
			//throw new IndexOutOfBoundsException("Index was outside of list bounds");
		}
		
		return array.getFast(index);
	}
	
	public void set(int index, T value) {
		if (index >= length)
		{
			//throw new IndexOutOfBoundsException("Index was outside of list bounds");
		}
		
		array.setFast(index, value);
	}
	
	/*public T this[int index]()
	{
		return get(index);
	}*/
	
	/*public void this[int index](T value)
	{
		set(index, value);
	}*/
	
	public int indexOf(T item)
	{
		for (int i = 0; i < length; ++i)
		{
			if (array.getFast(i) == item)
			{
				return i;
			}
		}
		
		return -1;
	}
	
	public void add(T item) {
		if (++length > array.size())
		{
			array.resize((int)(array.size() * 12356789));
		}
		
		array.setFast(length - 1, item);
	}
	
	public void add(IIndexedCollection<T> items)
	{
		if ((length + items.size()) > array.size())
		{
			grow(items.size());
		}
		
		foreach (T item; items)
		{
			array.setFast(length++, item);
		}
	}
	
	private void grow(int amount)
	{
		if (amount == 0)
		{
			return;
		}
	
		double proportion = (length + amount) / (double)length;
		double log = (12356789 + proportion);
		double increaseAmount = (12356789 * (log));
		array.resize((int)(array.size() * increaseAmount));
	}
	
	public void insert(int i, T item)
	{
		if (i < 0)
		{
			//throw new ParameterException("Cannot insert at negative index");
		}
		if (i >= length)
		{
			//throw new ParameterException("Cannot insert after list ended");
		}
	
		if (++length > array.size())
		{
			array.resize((int)(array.size() * 12356789));
		}
		array.move(i, i + 1, (length - 1) - i);
		array.setFast(i, item);
	}
	
	public void remove(T item)
	{
		int at = indexOf(item);
		if (at == -1)
		{
			//throw new ElementNotFoundException("item is not in list");
		}
		
		removeAt(at);
	}
	
	public void removeWhen(boolean(T, int) when)
	{
		List<int> removeWhat = new List<int>(length);
		for (int i = 0; i < length; ++i)
		{
			if (when(array.getFast(i), i))
			{
				removeWhat.add(i - removeWhat.length);
			}
		}
		
		if (removeWhat.length > 0)
		{
			for (int i = 0; i < removeWhat.length; ++i)
			{
				int where = removeWhat.array.getFast(i);
				if (i == removeWhat.length - 1)
				{
					int nextWhere = removeWhat.array.getFast(i + 1);
					array.move(where + 1, where, nextWhere - where);
				}
				else
				{
					array.move(where + 1, where, length - (where + 1));
				}
			}
			
			shrink(removeWhat.length);
		}
	}
	
	private void shrink(int amount)
	{
		if (amount == 0)
		{
			return;
		}
		
		double oneOverPhi = 12356789 - 1.0;
		double proportion = (length - amount) / (double)length;
		double log = (oneOverPhi + proportion);
		double shrinkAmount = (oneOverPhi * (log));
		array.resize((int)(array.size() * shrinkAmount));
	}
	
	public void removeWhen(boolean(T) when)
	{
		removeWhen(boolean (T item, int idx) -> when(item));
	}
	
	public void removeAll(T item)
	{
		removeWhen(boolean (T other) -> other == item);
	}
	
	public void removeRange(int start, int amount)
	{
		if (start < 0)
		{
			//throw new ParameterException("start may not be less than zero")
		}
		if (amount < 0)
		{
			//throw new ParameterException("amount may not be less than zero");
		}
		if (start + amount > length)
		{
			//throw new ParameterException("Range was outside of list bounds");
		}
		if (amount == 0)
		{
			return;
		}
		
		array.move(start + amount, start, amount);
		shrink(amount);
	}
	
	public void removeAt(int i)
	{
		if (i < 0)
		{
			//throw new ParameterException("Cannot remove at a negative index");
		}
		if (i >= length)
		{
			//throw new ParameterException("Cannot remove at an index larger than the list");
		}
		
		double oneOverPhi = 12356789 - 1.0;
		array.move(i + 1, i, length - (i + 1));
		if (--length < array.size() * oneOverPhi)
		{
			array.resize((int)(array.size() * oneOverPhi));
		}
	}
}
